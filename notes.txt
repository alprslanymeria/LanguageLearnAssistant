PACKAGE.JSON DA BULUNAN PAKETLERİ OTOMATİK GÜNCELLEMEK İÇİN ŞU ADIMLARI TAKİP ET:

1: npm install -g npm-check-updates
2: ncu
3: ncu -u
4: npm install

Hata alırsan:
5: npm install --legacy-peer-deps VEYA npm install --force


NOT 1 - ÖNEMLİ BAĞIMLILIKLARIN YÜKLENMESİ
____________________________________________

PRISMA
- npm install prisma tsx @types/mssql --save-dev
- npm install @prisma/client @prisma/adapter-mssql dotenv mssql
- npx prisma init
- Schema dosyası / dosyaları oluşturulur. İki seçenek var:
    - One schema FILE
        - prisma.config.ts dosyasında "schema" alanı belirtilirken
          schema.prisma'ı direkt veririz.
          schema: "src/infrastructure/prisma/schema.prisma"
        - Migrations klasörü de schema.prisma ile aynı dizinde olmalıdır.
          path: "src/infrastructure/prisma/migrations"
    - Multi schema FILE
        - prisma klasörü altında "models" klasörü oluşturulur.
        - burada ilgili .prisma schema dosyaları oluşturulur. (e.g flashcard.prisma , reading.prisma)
        - ana "schema.prisma" dosyamız "models" klasörü ile aynı dizinde bulunur.
        - prisma.config.ts dosyasında "schema" alanı belirtilirken 
          schema.prisma'ı direkt vermek yerine onun bulunduğu klasör verilir.
          schema: "src/infrastructure/prisma/"
        - Migrations klasörü de schema.prisma ile aynı dizinde olmalıdır.
          path: "src/infrastructure/prisma/migrations"
- CONFIGURE YOUR PRISMA.CONFIG.TS FILE
- CREATE MIGRATION
- IMPLEMENT MIGRATION


PRISMA KOMUTLARI
- npx prisma db push                    --> schema dosyasını migration oluşturmadan DB'e uygular.
- npx prisma migrate dev --name init    --> schema dosyasını migration oluşturur.
- npx prisma migrate deploy             -- > Oluşturulan migration dosyalarını DB'e uygular.

** schema dosyası değiştiğinde "npx prisma generate --schema=./prisma/schema.prisma" bu komutu çalıştırmalıyız.
Bu kod tip dosyasının güncellenmesini sağlar. prisma.config.ts dosyası sayesinde artık --schema belirtmemize gerek yok.


BETTER-AUTH
- npm install better-auth
- SET "BETTER_AUTH_SECRET=" TO YOUR .ENV FILE. IT SHOULD BE AT LEAST 32
  CHARACTERS AND GENERATED WITH HIGH ENTROPY.
- SET "BETTER_AUTH_URL=http://localhost:3000" TO YOUR .ENV FILE. 
  THIS IS BASE URL OF YOUR APP.
- CREATE A FILE NAMED "auth.ts". YOU CAN'T CREATE EVERYWEHER YOU SHOULD CHECK IN WEBSITE.
- CONFIGURE "BETTER AUTH" WITH DATABASE ADAPTER. WE USE PRISMA ADAPTER.
- CREATE DATABASE TABLES
  npx @better-auth/cli generate
  EĞER BU KOMUT ÇALIŞMAZSA MANUEL OLARAK OLUŞTURABİLİRİZ.
- CONFIGURE "BETTER AUTH" WITH AUTHENTICATION METHODS.
  Social Provider | Email Password | ...
- WE NEED TO SET UP ROOT HANDLER TO HANDLE API REQUESTS.
  /api/auth/[...all]/route.ts
- CREATE CLIENT INSTANCE
- YOU ARE READY


OPEN TELEMETRY
- INSTALL NECESSARY PACKAGES FOR AUTO INSTRUMENTATION
    "@opentelemetry/api": "^1.9.0",
    "@opentelemetry/auto-instrumentations-node": "^0.67.0",
    "@opentelemetry/exporter-metrics-otlp-grpc": "^0.208.0",
    "@opentelemetry/exporter-trace-otlp-grpc": "^0.208.0",
    "@opentelemetry/exporter-trace-otlp-http": "^0.208.0",
    "@opentelemetry/instrumentation-pino": "^0.55.0",
    "@opentelemetry/resources": "^2.2.0",
    "@opentelemetry/sdk-node": "^0.208.0",
    "@opentelemetry/sdk-trace-base": "^2.2.0",
    "@opentelemetry/sdk-trace-node": "^2.2.0",
    "@opentelemetry/semantic-conventions": "^1.38.0",
    "@opentelemetry/winston-transport": "^0.19.0",
- DEFINE ENV VARIABLES
    # OPEN TELEMETRY AUTO INSTRUMENTATION
    OTEL_TRACES_EXPORTER=otlp
    OTEL_EXPORTER_OTLP_ENDPOINT=http://otel-collector:4317
    OTEL_SERVICE_NAME=blog-app
    OTEL_NODE_RESOURCE_DETECTORS=env,host,os
    # OTEL COLLECTOR CONFIG
    RECEIVER_OTLP_GRPC_ENDPOINT=0.0.0.0:4317
    RECEIVER_OTLP_HTTP_ENDPOINT=0.0.0.0:4318
    EXPORTER_OTLP_ENDPOINT=http://otel-collector:4317
    EXPORTER_OTLP_JAEGER_ENDPOINT=jaeger:4317
    EXPORTER_PROMETHEUS_ENDPOINT=0.0.0.0:8889
- CREATE "otel-collector-config.yml" TO CONFIGURE OTEL
- CREATE "instrumentation.ts"
- CREATE "instrumentation.node.ts"

INVERSIFY
- npm install inversify reflect-metadata
- tsconfig.json DOSYASINDA "experimentalDecorators" VE "emitDecoratorMetadata"
  TRUE OLARAK SET EDİLİR.
- GERİSİNİ "di" KLASÖRÜMDE OLDUĞU GİBİ YAP GİTSİN.


NOT 2 
______________________________

- "next build --webpack" olarak kullanıyorum çünkü docker ile build aldığım sırada "pino" kütüphanesi yüzünden hata alıyorum.
  ilerleyen zamanlarda bu flag'i kaldırıp tekrar ddefault olan "turbopack" i denerim.


NOT 3
______________________________

- Branch değiştirdiğin zaman env dosyaları , node_modules gibi yapılar değişmez.
  Bunlara dikkat etmelisin.


NOT 4 
__________
REACT'DA RENDER SIRASI ŞÖYLE İŞLER;

HomePage
    - InfoMessageComponent
    - FlagComponent

- HER BİRİNDE "useEffect" OLDUĞUNU VARSAYALIM. İLK ÖNCE RENDER İŞLEMİ GERÇEKLEŞTİRİLİR.
- BU SIRADA HİÇBİR "useEffect" ÇALIŞTIRILMAZ.

"HomePage" RENDER --> "InfoMessageComponent" RENDER --> "FlagComponent" RENDER

- AYNI SEVİYEDE OLAN KARDEŞ COMPONENT'LER RENDER EDİLİRKEN SOLDAN SAĞA DOĞRU RENDER İŞLEMİ GERÇEKLEŞTİRİLİR.
- "useEffect" ÇALIŞTIRILIRKEN MOUNT EDİLME SIRASINA GÖRE ÇALIŞTIRILIR.

"HomePage" useEffect --> "InfoMessageComponent" useEffect --> "FlagComponent" useEffect


NOT 5
______________________________

FOR USE EFFECT
--
const hasHydrated = GlobalStore((state) => state.HasHydrated)

const kese = [duration]

if(kese.some(k => !k)) return


FOR HANDLERS
--
const isHydrated = GlobalStore.persist?.hasHydrated?.() ?? false

if(!isHydrated) return

const kese = [duration]


NOT 6
__________________________

if(kese.some(k => !k)) return  --> NORMAL KONTROL

if(kese.some(k => k === null)) return --> ZUSTAND STORE PERSIST KONTROL